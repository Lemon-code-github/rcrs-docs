\documentclass{article}
%% Packages
\usepackage[a4paper,top=2cm,left=2.5cm, right=2.5cm,bottom=3cm,footskip=0.75cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[hidelinks,driverfallback=dvipdfmx]{hyperref}
\usepackage[dvipdfmx]{graphicx}
\usepackage{epstopdf}
\usepackage{subcaption}
\usepackage[authoryear,round]{natbib}
\usepackage{tcolorbox}
\usepackage{listings}
\lstset{
  language={Java},
  basicstyle = \scriptsize\ttfamily,
  breaklines = true,
  breakindent = 40pt,
  numbers=left,
  numberstyle = {\tiny \emph},
  frame = tlRB,
  frameround = ffft,
  framesep = 3pt,
  rulesep = 1pt,
  rulecolor = {\color{blue}},
  rulesepcolor = {\color{blue}},
  flexiblecolumns = true,
  keepspaces = false,
  identifierstyle = \itshape\scriptsize,
  commentstyle = \fontfamily{ptm}\selectfont\scriptsize\color{red},
  stringstyle = \scshape\scriptsize,
  tabsize = 2
}
%%
\oddsidemargin -5.4mm
\evensidemargin -5.4mm
\textwidth 170mm
\topmargin -5.4mm
\headheight 0pt
\headsep 0pt
\textheight 257mm
\usepackage{ascmac}
%%
\begin{document}
%%
\title{RoboCup Rescue Simulator and Agent Development Framework Manual}
\author{}
\date{October 15, 2018}
%%
\maketitle
%%
\tableofcontents
%%
\section{Introduction}
A \emph{disaster} may be defined as a crisis situation causing widespread human, material, economical and environmental damages that surpasses the system's capacity to recover. There are two main ways of treating a disaster:

\begin{enumerate}
  \item Preventing it from happening, which can be done through identifying its causes and preventing them from taking place.
  \item Managing its impacts once they happen through the application of previously established governmental policies and strategies.
\end{enumerate}

The former option is usually more desirable, since it is very effective and very little disrupting. However, this is not always possible, since some events are too intense to be avoided even if forecasted with great antecedence, and others are unpredictable. Thus, the management option becomes necessary for the mitigation of the disaster's impacts.

After the 1995 Kobe earthquake events, Japanese researchers came up with the idea of developing a simulator that reproduces conditions similar to a urban post-earthquake in order to test mitigation strategies for this kind of disaster. They also organized a competition, the RoboCup Rescue Agent Simulation League, in which people from all over the world would be able to demonstrate their advancements in the coordination of rescuing agents teams running in this simulator and to help in the development of policies and strategies to mitigate the impact of such disasters.

The purpose of this manual is to facilitate the understanding of the first contact with the RoboCup Rescue Simulation server and to help people interested in participating in RoboCup Rescue Agent Simulation competitions.
%%
\section{Installation}
%%
This manual assumes the simulator and agents will run in a Linux machine even though it is possible to run them in Microsoft Windows or Apple macOS. We recommend to use Linux because it is open-source and most of the distributions have a good support from the users' community. If you have never used Linux before and intend to, we recommend starting with a user-friendly distribution, such as Ubuntu\footnote{\url{https://www.ubuntu.com/}} or Fedora\footnote{\url{https://getfedora.org}}.
%%
\subsection{Software Requirements}
%%
 \begin{itemize}
  \item Java OpenJDK 8+\footnote{\url{https://openjdk.java.net/}}
  \item Git
  \item Gradle
  \item Utilities like \emph{wget}, \emph{bash}, \emph{xterm}, \emph{tar}, \emph{gzip}, etc.\\
        If you are using Ubuntu, all of these software are present in the
        default software repositories.
 \end{itemize}
%%
%%
\subsection{Installing RoboCup Rescue Simulation (RCRS) Server}
\begin{enumerate}
 \item Clone the simulation server from
       \url{https://github.com/roborescue/rcrs-server}.
 \item Change to the directory ``rcrs-server''.
       \begin{enumerate}
         \item If you use macOS, patch the file ``boot/functions.sh'' like\\
               ``\verb|sed -i -e "/readlink/s/^/#/" boot/functions.sh|''.
       \end{enumerate}
 \item Compile the simulator using the commands \texttt{gradle clean}
       and \texttt{gradle completeBuild}.
 \item Check the message at the end of the installation.
       If the installation is successfully completed, you get the message \texttt{BUILD SUCCESSFUL}; otherwise you get \texttt{BUILD FAILED}.
\end{enumerate}

If you are using Ubuntu, the installation proceeds according to the commands below:

\begin{center}
  \begin{tcolorbox}[title=Installation on Ubuntu, width=.98\linewidth]
  {\ttfamily\small
  \$ git clone https://github.com/roborescue/rcrs-server.git\\
   \$ cd rcrs-server\\
   (\$ sed -i -e \verb|"/readlink/s/^/#/"| boot/functions.sh \# Only required for macOS)\\
  \$ gradle clean\\
  \$ gradle completeBuild
  }
  \end{tcolorbox}
\end{center}

The following message will be appeared if the installation is successfully completed.

\begin{center}
  \begin{tcolorbox}[title=Install Completion, width=.98\linewidth]
  {\ttfamily
  BUILD SUCCESSFUL in 2s\\
  1 actionable task: 1 executed
  }
  \end{tcolorbox}
\end{center}
%%
\subsection{Compiling the Agent Development Framework (ADF) Sample Agents}
%%
Download the sample agents with ADF by cloning the \url{https://github.com/roborescue/rcrs-adf-sample.git} repository. Then, you move to \texttt{rcrs-adf-sample} directory and compile the sample agents using the
script \texttt{compile.sh}.

If you are using Ubuntu, you can get and compile the ADF with the following commands:

\begin{center}
  \begin{tcolorbox}[title=Download ADF on Ubuntu, width=.98\linewidth]
  {\ttfamily\small
  \$ git clone https://github.com/roborescue/rcrs-adf-sample.git\\
   \$ cd rcrs-adf-sample\\
   \$ java -jar ./library/rescue/adf/adf-core.jar -compile
  }
  \end{tcolorbox}
\end{center}
%%
%%
\section{Running the ADF Sample Agents on RCRS Server}
%%
\subsection{Running without Precomputation}
%%
To run the sample agents, you must open two terminal windows. One is used to run the simulation server (i.e., the simulator) and the other is used to run the agents.
%%
\subsubsection{Running the Simulation Server}
%%
Use one terminal window and move to the boot directory inside the simulator's folder (\texttt{rcrs-server}). Then, type \texttt{bash start-comprun.sh}. The sequence of commands are:
%%
\begin{center}
   \begin{tcolorbox}[title=Running Simulation Server, width=.98\linewidth]
    {\ttfamily
    \$ cd rcrs-server\\
    \$ cd boot\\
    \$ bash start-comprun.sh
    }
  \end{tcolorbox}
\end{center}
%%

When the simulation server runs correctly, the window in Fig. \ref{fig:simulator01} will appear.
%%
\begin{figure}[ht]
 \begin{center}
  \includegraphics[width=.9\linewidth]{figs/simulator01.eps}
  \caption{Running the Simulation Server}
  \label{fig:simulator01}
 \end{center}
\end{figure}
%%
%%
\subsubsection{Running the ADF Sample Agents}
%%
After running the simulation server, move to \texttt{rcrs-adf-sample} directory on the other terminal window and run the agents by the following commands:
%%
\begin{center}
   \begin{tcolorbox}[title=Running Sample Agents, width=.98\linewidth]
    {\ttfamily
    \$ sh launch.sh -all\\
    $[$FINISH$]$ Done connecting to server (3 agents)
    }
  \end{tcolorbox}
\end{center}
%%

If the agents can connect with the simulator, the state of the agents and a city are shown on the left-hand side in the window shown in Fig. \ref{fig:simulator01}. Then, the simulation is started as shown in Fig. \ref{fig:simulator02}.
%%
\begin{figure}[ht]
 \begin{center}
  \includegraphics[width=1.0\linewidth]{figs/simulator02.eps}
  \caption{Starting the Simulation}
  \label{fig:simulator02}
 \end{center}
\end{figure}
%%
%%
\subsection{Running with Precomputation}
%%
Agents can examine a simulation scenario by performing a precomputation of it before starting the simulation. The length of the precomputation is predefined to 2 minutes in the competition. The precomputation needs two terminal windows likewise.
%%
\subsubsection{Running the Simulation Server for Precomputation}
%%
Use one terminal window and move to the boot directory inside the simulator's folder (\texttt{rcrs-server}). Then, type \texttt{bash start-precompute.sh}. These commands are:
%%
\begin{center}
   \begin{tcolorbox}[title=Running Simulation Server, width=.98\linewidth]
    {\ttfamily
    \$ cd rcrs-server\\
    \$ cd boot\\
    \$ bash start-precompute.sh
    }
  \end{tcolorbox}
\end{center}
%%
%%
\subsubsection{Running the ADF Sample Agents for Precomputation}
%%
After running the simulation server for the precomputation, move to the ADF directory on the other terminal window and run the agents executing the commands:
%%
\begin{center}
   \begin{tcolorbox}[title=Running Sample Agents, width=.98\linewidth]
    {\ttfamily
    \$ sh launch.sh -t 1,0,1,0,1,0 -h localhost -pre 1 \& APID=\$! ; sleep 120 ;
    kill \$APID\\
    $[$START $]$ Connect to server (host:localhost, port:7000)\\
    $[$INFO  $]$ Connected - adf.agent.platoon.PlatoonFire@756ec19c (PRECOMPUTATION)\\
    $[$INFO  $]$ Connected - adf.agent.platoon.PlatoonPolice@366bbbe (PRECOMPUTATION)\\
    $[$INFO  $]$ Connected - adf.agent.platoon.PlatoonAmbulance@2a453513 (PRECOMPUTATION)\\
    ********************\\
    $[$FINISH$]$ Connect PoliceForce (success:1)\\
    $[$FINISH$]$ Connect AmbulanceTeam (success:1)\\
    $[$FINISH$]$ Connect FireBrigade (success:1)\\
    $[$FINISH$]$ Done connecting to server (3 agents)
    }
  \end{tcolorbox}
\end{center}
%%
%%
\subsubsection{Running the Simulation}
%%
When the precomputation is completed, push \texttt{Control-C} and type \texttt{sh kill.sh} to stop the simulation server of running. Then, type \texttt{bash start-comprun.sh} to start the simulation server again to run the simulation scenario. The commands are:
%%
\begin{center}
   \begin{tcolorbox}[title=Running Simulation Server, width=.98\linewidth]
    {\ttfamily
    Control-C\\
    \$ sh kill.sh\\
    \$ bash start-comprun.sh
    }
  \end{tcolorbox}
\end{center}
%%
%%
\subsubsection{Running the ADF Sample Agents}
%%
After running the simulation server, move to the ADF directory on the other terminal window and run the agents using the commands:
%%
\begin{center}
   \begin{tcolorbox}[title=Running Sample Agents, width=.98\linewidth]
    {\ttfamily
    \$ sh lauch.sh -all\\
    $[$FINISH$]$ Done connecting to server (3 agents)
    }
  \end{tcolorbox}
\end{center}
%%
%%
\section{Simulation Server Options}
%%
\subsection{Directories}
%%
Important directories of the simulation server are:
%%
\begin{itemize}
 \item \texttt{boot/}: scripts to run the simulation server
       \begin{itemize}
         \item \texttt{boot/config/}: configuration files of the simulation server.
         \item \texttt{boot/logs/}: log files.
       \end{itemize}
 \item \texttt{build/}: the simulation server's Java classes.
 \item \texttt{jars/}: the simulation server's JAR files.
 \item \texttt{lib/}: libraries used by the simulation server.
 \item \texttt{maps/}: maps that can be ran in the simulation server.
 \item \texttt{modules/}: the simulation server's source code.
 \item \texttt{oldsims/}: source code of some of the simulation server's older versions.
\end{itemize}
%%
%%
\subsection{Parameters}
%%
The following parameters can be used to run the simulation server:
%%
\begin{itemize}
  \item -m MAPDIR or {-}{-}map MAPDIR, where MAPDIR is the path to the directory containing the map you want to run (default is ../maps/gml/Kobe2013/map).
  \item -c CONFIGDIR or {-}{-}config CONFIGDIR, where CONFIGDIR is the directory containing the configuration associated with a map (default is ./config).
  \item -l LOGDIR or {-}{-}log LOGDIR, where LOGDIR is the directory where the log files will be stored (default is ./logs).
\end{itemize}
%%

These parameters can be used at running a precomputaion and a simulation. You must use the same parameters regarding MAPDIR and CONFIGDIR to run a simulation server with or without precomputation. An example of how to run the simulation server using these parameters is:
%%
\begin{center}
   \begin{tcolorbox}[title=Running Simulation Server with Options, width=.98\linewidth]
    {\ttfamily
    \$ bash start-precompute.sh -m ../maps/gml/berlin -l logs2\\
    (After completing agents' precomputation)\\
    Control-C\\
    \$ sh kill.sh\\
    \$ bash start-comprun.sh -m ../maps/gml/berlin -l logs2
    }
  \end{tcolorbox}
\end{center}
%%
%%
\section{How to Create Your Own Agents with ADF}
%%
This section explain how to implement your agents using ADF samples.
%%
\subsection{Important Directories}
%%
Important directories of ADF (\texttt{rcrs-adf-sample}) are:
%%
\begin{itemize}
 \item \texttt{config/}: configuration file of agents.
 \item \texttt{src/}: agents' source codes.
 \item \texttt{precomp\_data/}: results of a precomputation for each type of agents.
 \item \texttt{build/}: agents' Java classes.
 \item \texttt{library/}: libraries used by agents.
\end{itemize}
%%
%%
\subsection{Files to Create Your Agents}
%%
You can develop your own agents codes using only the files in the directories:
%%
\begin{itemize}
 %%
 \item \texttt{src/adf/sample/centralized}: source codes for {\itshape central agents}. This is the type of agents whose only interaction with the world is through radio communication. There are three types of central agents: \textit{Ambulance Centers}, \textit{Fire Stations} and \textit{Police Office}, and they are represented as buildings in the simulation server.
 %%
 \item \texttt{src/adf/sample/extraction}: codes of combining actions described in the directory below.
 %%
 \item \texttt{src/adf/sample/module}: concrete codes of algorithms, e.g. path planning, clustering, target detection, etc. The directory contains two directories:
 %%
 \begin{itemize}
    \item \texttt{src/adf/sample/module/algorithm}
    \item \texttt{src/adf/sample/module/complex}
 \end{itemize}
\end{itemize}

\begin{itembox}[l]{Note}
{\bfseries You must not make any changes of files in \texttt{src/adf/sample/tactics}.} This is the restriction for our current competition rule.
\end{itembox}

You should fundamentally copy the sample codes, not edit them. The reason is that the sample codes would be used if ADF could not find your own codes. You can easily change reference to your modules by modifying \texttt{src/adf/config/module.cfg}. The usage of the file is described below.
%%
\subsection{Work Flow of Coding Your Agents}
%%
The steps necessary to code your own agents are:
%%
\begin{enumerate}
 \item Copy sample codes related to agents which you want to create,
 \item Edit the copied files.
 \item Edit \texttt{src/adf/config/module.cfg} according to the edited files.
 \item Compile and run.
\end{enumerate}
%%
%%
\subsection{Modules Configuration File}
%%
The modules configuration file \texttt{src/adf/config/module.cfg} indicates which codes would be used as agents' module. Fig.~\ref{fig:module.cfg} shows part of the modules configuration file. The left-hand side of the colon indicates the module name, the right-hand side is the class name. In most cases, modules of which targets' problems are the same should refer to an identical class for all agent types. The example in Fig.~\ref{fig:module.cfg} is in \texttt{TacticsAmbulanceTeam.Search} and \texttt{TacticsFireBrigade.Search} indicates that both modules refer to \\
\texttt{adf.sample.module.complex.SampleSearch}. An usage example is shown in Section~\ref{subsubsec:module.cfg}.


\begin{figure}[ht]
 \begin{center}
  \begin{screen}
   {\ttfamily\small
TacticsAmbulanceTeam.HumanDetector : adf.sample.module.complex.SampleHumanDetector\\
TacticsAmbulanceTeam.Search : adf.sample.module.complex.SampleSearch\\

TacticsAmbulanceTeam.ActionTransport : adf.sample.extaction.ActionTransport\\
TacticsAmbulanceTeam.ActionExtMove : adf.sample.extaction.ActionExtMove\\

TacticsAmbulanceTeam.CommandExecutorAmbulance : adf.sample.centralized.CommandExecutorAmbulance\\
TacticsAmbulanceTeam.CommandExecutorScout : adf.sample.centralized.CommandExecutorScout\\

TacticsFireBrigade.BuildingDetector : adf.sample.module.complex.SampleBuildingDetector\\
TacticsFireBrigade.Search : adf.sample.module.complex.SampleSearch\\

TacticsFireBrigade.ActionFireFighting : adf.sample.extaction.ActionFireFighting\\
TacticsFireBrigade.ActionExtMove : adf.sample.extaction.ActionExtMove\\
$\vdots$
}
  \end{screen}
  \caption{Modules Configuration File}
  \label{fig:module.cfg}
 \end{center}
\end{figure}
%%
%%
\subsection{Example of Implementing A* Algorithm for Path Planning Algorithm}
%%
\subsubsection{Copy A Sample Code}
%%
First of all, you should copy the sample code for path planning which is \texttt{SamplePathPlanning.java}. The example is described below. Note that the second command is split into two lines because of space limitations, but it should be entered as a single line.
%%
\begin{center}
   \begin{tcolorbox}[title=Copy the Sample Path Planning, width=.98\linewidth]
    {\ttfamily
    \$ mkdir -p src/myteam/module/algorithm\\
    \$ cp src/adf/sample/module/algorithm/SamplePathPlanning.java src/myteam/module/algorithm/AStarPathPlanning.java
    }
  \end{tcolorbox}
\end{center}
%%
\subsubsection{Editing the Sample Code}
Listing~\ref{samplepathplan} is the code of \texttt{SamplePathPlanning.java},
which has Dijkstra's algorithm. You should edit 1st line, 18th line and 27th line (these lines are indicated with red comments). You would implement your own code in the method \texttt{calc()}, and remove the method \texttt{isGoal()} that is only used by \texttt{calc()}. Listing~\ref{astarpathplan1} shows the results of editing these lines.

You must implement the method \texttt{calc()} to get its calculation result
by the method \texttt{getResult()}. The type of \texttt{getResult()} returning is \texttt{List$<$EntityID$>$}.

Listing~\ref{astarpathplan2} indicates the contents of the method
\texttt{calc()}. In addition you should write the new private class \texttt{Node} which is used by the method \texttt{calc()}. The code is shown in listing~\ref{astarpathplan3}. It must be put in the file \texttt{AStarPathPlanning.java}.
%%
\begin{lstlisting}[caption=SamplePathPlanning.java,label=samplepathplan]
package adf.sample.module.algorithm; // Edit this line

import adf.agent.communication.MessageManager;
import adf.agent.develop.DevelopData;
import adf.agent.info.AgentInfo;
import adf.agent.info.ScenarioInfo;
import adf.agent.info.WorldInfo;
import adf.agent.module.ModuleManager;
import adf.agent.precompute.PrecomputeData;
import adf.component.module.algorithm.PathPlanning;
import rescuecore2.misc.collections.LazyMap;
import rescuecore2.standard.entities.Area;
import rescuecore2.worldmodel.Entity;
import rescuecore2.worldmodel.EntityID;

import java.util.*;

public class SamplePathPlanning extends PathPlanning { // Edit this line

    private Map<EntityID, Set<EntityID>> graph;

    private EntityID from;
    private Collection<EntityID> targets;
    private List<EntityID> result;
    // Edit the following line
    public SamplePathPlanning(AgentInfo ai, WorldInfo wi, ScenarioInfo si, ModuleManager moduleManager, DevelopData developData) {
        super(ai, wi, si, moduleManager, developData);
        this.init();
    }

    private void init() {
        Map<EntityID, Set<EntityID>> neighbours = new LazyMap<EntityID, Set<EntityID>>() {
            @Override
            public Set<EntityID> createValue() {
                return new HashSet<>();
            }
        };
        for (Entity next : this.worldInfo) {
            if (next instanceof Area) {
                Collection<EntityID> areaNeighbours = ((Area) next).getNeighbours();
                neighbours.get(next.getID()).addAll(areaNeighbours);
            }
        }
        this.graph = neighbours;
    }

    @Override
    public List<EntityID> getResult() {
        return this.result;
    }

    @Override
    public PathPlanning setFrom(EntityID id) {
        this.from = id;
        return this;
    }

    @Override
    public PathPlanning setDestination(Collection<EntityID> targets) {
        this.targets = targets;
        return this;
    }

    @Override
    public PathPlanning updateInfo(MessageManager messageManager) {
        super.updateInfo(messageManager);
        return this;
    }

    @Override
    public PathPlanning precompute(PrecomputeData precomputeData) {
        super.precompute(precomputeData);
        return this;
    }

    @Override
    public PathPlanning resume(PrecomputeData precomputeData) {
        super.resume(precomputeData);
        return this;
    }

    @Override
    public PathPlanning preparate() {
        super.preparate();
        return this;
    }

    @Override
    public PathPlanning calc() {     // Renew this method (implement your algrithm here)
        List<EntityID> open = new LinkedList<>();
        Map<EntityID, EntityID> ancestors = new HashMap<>();
        open.add(this.from);
        EntityID next;
        boolean found = false;
        ancestors.put(this.from, this.from);
        do {
            next = open.remove(0);
            if (isGoal(next, targets)) {
                found = true;
                break;
            }
            Collection<EntityID> neighbours = graph.get(next);
            if (neighbours.isEmpty()) {
                continue;
            }
            for (EntityID neighbour : neighbours) {
                if (isGoal(neighbour, targets)) {
                    ancestors.put(neighbour, next);
                    next = neighbour;
                    found = true;
                    break;
                }
                else {
                    if (!ancestors.containsKey(neighbour)) {
                        open.add(neighbour);
                        ancestors.put(neighbour, next);
                    }
                }
            }
        } while (!found && !open.isEmpty());
        if (!found) {
            // No path
            this.result = null;
        }
        // Walk back from goal to this.from
        EntityID current = next;
        LinkedList<EntityID> path = new LinkedList<>();
        do {
            path.add(0, current);
            current = ancestors.get(current);
            if (current == null) {
                throw new RuntimeException("Found a node with no ancestor! Something is broken.");
            }
        } while (current != this.from);
        this.result = path;
        return this;
    }
    // Remove the method (it is only used by calc()).
    private boolean isGoal(EntityID e, Collection<EntityID> test) {
        return test.contains(e);
    }
}
\end{lstlisting}

\begin{lstlisting}[caption=Part of AStarPlanning.java,label=astarpathplan1]
package myteam.module.algorithm; // Position of the file

import adf.agent.communication.MessageManager;
import adf.agent.develop.DevelopData;
import adf.agent.info.AgentInfo;
import adf.agent.info.ScenarioInfo;
import adf.agent.info.WorldInfo;
import adf.agent.module.ModuleManager;
import adf.agent.precompute.PrecomputeData;
import adf.component.module.algorithm.PathPlanning;
import rescuecore2.misc.collections.LazyMap;
import rescuecore2.standard.entities.Area;
import rescuecore2.worldmodel.Entity;
import rescuecore2.worldmodel.EntityID;

import java.util.*;

public class AStarPathPlanning extends PathPlanning { // Same as the file name

    private Map<EntityID, Set<EntityID>> graph;

    private EntityID from;
    private Collection<EntityID> targets;
    private List<EntityID> result;
    // Same as the file name
    public AStarPathPlanning(AgentInfo ai, WorldInfo wi, ScenarioInfo si, ModuleManager moduleManager, DevelopData developData) {
        super(ai, wi, si, moduleManager, developData);
        this.init();
    }
\end{lstlisting}

\lstset{%
language={Java},%
basicstyle = \scriptsize\ttfamily,
breaklines = true,
breakindent = 40pt,
firstnumber=88,
numbers=left,
numberstyle = {\tiny \emph},
frame = tlRB,
frameround = ffft,
framesep = 3pt,
rulesep = 1pt,
rulecolor = {\color{blue}},
rulesepcolor = {\color{blue}},
flexiblecolumns = true,
keepspaces = false,
identifierstyle = \itshape\scriptsize,
commentstyle = \fontfamily{ptm}\selectfont\scriptsize\color{red},
stringstyle = \scshape\scriptsize,
tabsize = 2,
}
%%
\begin{lstlisting}[caption=calc(),label=astarpathplan2]
    @Override
    public PathPlanning calc() {
        List<EntityID> open = new LinkedList<>();
        List<EntityID> close = new LinkedList<>();
        Map<EntityID, Node> nodeMap = new HashMap<>();
        open.add(this.from);
        nodeMap.put(this.from, new Node(null, this.from));
        close.clear();

        while (true) {
            if (open.size() < 0) {
                this.result = null;
                return this;
            }
            Node n = null;
            for (EntityID id : open) {
                Node node = nodeMap.get(id);
                if (n == null) {
                    n = node;
                } else if (node.estimate() < n.estimate()) {
                    n = node;
                }
            }
            if (targets.contains(n.getID())) {
                List<EntityID> path = new LinkedList<>();
                while (n != null) {
                    path.add(0, n.getID());
                    n = nodeMap.get(n.getParent());
                }
                this.result = path;
                return this;
            }
            open.remove(n.getID());
            close.add(n.getID());

            Collection<EntityID> neighbours = this.graph.get(n.getID());
            for (EntityID neighbour : neighbours) {
                Node m = new Node(n, neighbour);
                if (!open.contains(neighbour) && !close.contains(neighbour)) {
                    open.add(m.getID());
                    nodeMap.put(neighbour, m);
                }
                else if (open.contains(neighbour) && m.estimate() < nodeMap.get(neighbour).estimate()) {
                    nodeMap.put(neighbour, m);
                }
                else if (!close.contains(neighbour) && m.estimate() < nodeMap.get(neighbour).estimate()) {
                    nodeMap.put(neighbour, m);
                }
            }
        }
    }
\end{lstlisting}
%%

\lstset{%
language={Java},%
basicstyle = \scriptsize\ttfamily,
breaklines = true,
breakindent = 40pt,
%firstnumber=88,
numbers=none,
%numberstyle = {\tiny \emph},
frame = tlRB,
frameround = ffft,
framesep = 3pt,
rulesep = 1pt,
rulecolor = {\color{blue}},
rulesepcolor = {\color{blue}},
flexiblecolumns = true,
keepspaces = false,
identifierstyle = \itshape\scriptsize,
commentstyle = \fontfamily{ptm}\selectfont\scriptsize\color{red},
stringstyle = \scshape\scriptsize,
tabsize = 2,
}
\begin{lstlisting}[caption=Node Class,label=astarpathplan3]
private class Node {
    EntityID id;
    EntityID parent;

    double cost;
    double heuristic;

    public Node(Node from, EntityID id) {
        this.id = id;

        if (from == null) {
            this.cost = 0;
        } else {
            this.parent = from.getID();
            this.cost = from.getCost() + worldInfo.getDistance(from.getID(), id);
        }

        this.heuristic = worldInfo.getDistance(id, targets.toArray(new EntityID[targets.size()])[0]);
    }

    public EntityID getID() {
        return id;
    }

    public double getCost() {
        return cost;
    }

    public double estimate() {
        return cost + heuristic;
    }

    public EntityID getParent() {
        return this.parent;
    }
}
\end{lstlisting}
%%
%%
\subsubsection{Editing the Module Configuration File}
\label{subsubsec:module.cfg}
%%
You must edit the module configuration file \texttt{src/adf/config/module.cfg} related to a path planning to use your code. The Figs.~\ref{fig:default_module.cfg} and~\ref{fig:edited_module.cfg} show the part of the default module.cfg and the part of the edited module.cfg where the lines related to a path planning are changed. In this case, all \texttt{adf.sample.module.algorithm.SamplePathPlanning} in the file are replaced with \texttt{myteam.module.algorithm.AStarPathPlanning}. If you would like to use the code in some modules, you can indicate that the only modules refer to it.
%%
\begin{figure}[ht]
 \begin{center}
  \begin{screen}
   {\ttfamily
SampleRoadDetector.PathPlanning : adf.sample.module.algorithm.SamplePathPlanning\\
SampleSearch.PathPlanning.Ambulance : adf.sample.module.algorithm.SamplePathPlanning\\
SampleSearch.PathPlanning.Fire : adf.sample.module.algorithm.SamplePathPlanning\\
SampleSearch.PathPlanning.Police : adf.sample.module.algorithm.SamplePathPlanning\\
ActionExtClear.PathPlanning : adf.sample.module.algorithm.SamplePathPlanning\\
ActionExtMove.PathPlanning : adf.sample.module.algorithm.SamplePathPlanning\\
ActionFireFighting.PathPlanning : adf.sample.module.algorithm.SamplePathPlanning\\
ActionTransport.PathPlanning : adf.sample.module.algorithm.SamplePathPlanning\\
CommandExecutorAmbulance.PathPlanning : adf.sample.module.algorithm.SamplePathPlanning\\
CommandExecutorFire.PathPlanning : adf.sample.module.algorithm.SamplePathPlanning\\
CommandExecutorPolice.PathPlanning : adf.sample.module.algorithm.SamplePathPlanning\\
CommandExecutorScout.PathPlanning : adf.sample.module.algorithm.SamplePathPlanning\\
CommandExecutorScoutPolice.PathPlanning : adf.sample.module.algorithm.SamplePathPlanning
}
  \end{screen}
  \caption{Default module.cfg}
  \label{fig:default_module.cfg}
 \end{center}
\end{figure}

\begin{figure}[ht]
 \begin{center}
\begin{screen}
{\ttfamily
SampleRoadDetector.PathPlanning : myteam.module.algorithm.AStarPathPlanning\\
SampleSearch.PathPlanning.Ambulance : myteam.module.algorithm.AStarPathPlanning\\
SampleSearch.PathPlanning.Fire : myteam.module.algorithm.AStarPathPlanning\\
SampleSearch.PathPlanning.Police : myteam.module.algorithm.AStarPathPlanning\\
ActionExtClear.PathPlanning : myteam.module.algorithm.AStarPathPlanning\\
ActionExtMove.PathPlanning : myteam.module.algorithm.AStarPathPlanning\\
ActionFireFighting.PathPlanning : myteam.module.algorithm.AStarPathPlanning\\
ActionTransport.PathPlanning : myteam.module.algorithm.AStarPathPlanning\\
CommandExecutorAmbulance.PathPlanning : myteam.module.algorithm.AStarPathPlanning\\
CommandExecutorFire.PathPlanning : myteam.module.algorithm.AStarPathPlanning\\
CommandExecutorPolice.PathPlanning : myteam.module.algorithm.AStarPathPlanning\\
CommandExecutorScout.PathPlanning : myteam.module.algorithm.AStarPathPlanning\\
CommandExecutorScoutPolice.PathPlanning : myteam.module.algorithm.AStarPathPlanning
}
\end{screen}
  \caption{Edited module.cfg}
  \label{fig:edited_module.cfg}
 \end{center}
\end{figure}
%%
\newpage
%%
\section{RoboCup Rescue Simulation Server}
%%
\subsection{Architecture}
%%
The simulator is in fact divided into many other simulators:
%%
\begin{itemize}
  \item the \texttt{clear} simulator, responsible for blockade removal;
  \item the \texttt{collapse} simulator, responsible for managing buildings' structural damage and blockade creation;
  \item the \texttt{ignition} simulator, responsible for firing up random buildings during the simulation;
  \item the \texttt{fire} simulator, responsible for the fire spread between buildings;
  \item the \texttt{traffic} simulator, responsible for humans' movement;
  \item the \texttt{misc} simulator, responsible for human damage and buriedness.
\end{itemize}
%%

These simulators establish connections to the \emph{kernel simulator}, responsible for coordinating the simulators' processes and centralizing the data they generate.
%%
\begin{figure}[ht]
  \centering
  \includegraphics[width=0.5\textwidth]{figs/simulator_architecture.eps}
  \caption{RoboCup Rescue Agent Simulation platform architecture~\cite{skinnerRamchurn2010}}
  \label{fig:simulator_architecture}
\end{figure}

The RoboCup Rescue simulator was designed to create a \emph{partially observable}, \emph{discrete-time}, \emph{dynamic}, \emph{stochastic}, \emph{multiagent} environment. In other words, in this environment:

\begin{itemize}
  \item the complete world current state cannot be known through a single agent's perception (even if the agent has an infinite range of sight, it still will not be able to see through a building's walls);
  \item time is divided in intervals, as opposed to continuous time;
  \item there are random elements that affect its state transition;
  \item there is more than one agent present, and one's actions may interfere with the others' performance.
\end{itemize}

Time is divided in \emph{time-steps}; during each time-step, the agent perceives the environment and reasons about what action it will perform. In each time-step, the following happens:
%%
\begin{enumerate}
\label{enum:time-step}
  \item The kernel updates all agents' perception (visual and communication) and waits for the agents' commands.
  \item The agents updates their world model and make their decisions, sending their commands to the kernel.
  \item The kernel sends the agents' commands to the simulators.
  \item The simulators process the agents' commands and send the changes suffered by the environment back to the kernel.
  \item The kernel sends the environment changes to the viewers.
\end{enumerate}
%%
%%
\subsection{Entities}
%%
Several objects are represented in the simulator as depicted in Figure~\ref{fig:entities}.
%%
\begin{figure}[ht]
  \centering
  \includegraphics[width=1.0\textwidth]{figs/entities.eps}
  \caption{Entities of the simulator}
  \label{fig:entities}
\end{figure}
%%
%%
\subsubsection{Blockades}
%%
Blockades obstruct the path of agents and civilians; they are represented as black polygons in roads. Blockades appear in the beginning of the simulation and are not produced after this. They must be removed by Police Forces.

\paragraph{Properties}
%%
\begin{itemize}
  \item \texttt{position}: ID of the road to which the blockade belongs
  \item \texttt{repair cost}: cost to completely remove the blockade from the road
  \item \texttt{shape}: a rectangle which surrounds the whole blockade
  \item \texttt{X} \& \texttt{Y}: coordinates of the blockade's centroid
  \item \texttt{apexes}: vector containing the apexes of the blockade
\end{itemize}
%%
%%
\subsubsection{Area}
%%
Area entities represent buildings and roads.

\paragraph{Properties}
%%
\begin{itemize}
  \item \texttt{blockades}: a list with the blockades in that area
  \item \texttt{edges}: a list with the edges that limit the area
  \item \texttt{neighbours}: a list of the areas that can be accessed from this area
  \item \texttt{X} \& \texttt{Y}: coordinates representing the area in the map
\end{itemize}
%%

While both buildings and roads have the \emph{blockades} attribute, blockades appear only in roads.
%%
\subsubsection{Buildings}

Buildings group all kinds of buildings in the simulator: besides the regular ones, described below, there are special kinds of buildings (\emph{refuges}, \emph{ambulance centres}, \emph{fire stations} and \emph{police offices}, shown in Figure~\ref{fig:special_buildings}) which cannot catch on fire. They will be described in later sections of this document.
%%
\begin{figure}[htp]
  \centering
  \begin{subfigure}[hb]{0.45\textwidth}
    \centering
    \includegraphics[scale=0.6]{figs/refuge.eps}
    \caption{Refuge}
    \label{fig:refuge}
  \end{subfigure}
  \begin{subfigure}[hb]{0.45\textwidth}
    \centering
    \includegraphics[scale=0.6]{figs/ambulance_central.eps}
    \caption{Ambulance Central}
    \label{fig:ambulance_central}
  \end{subfigure}

  \begin{subfigure}[hb]{0.45\textwidth}
    \centering
    \includegraphics[scale=0.6]{figs/fire_station.eps}
    \caption{Fire Station}
    \label{fig:fire_station}
  \end{subfigure}
  \begin{subfigure}[hb]{0.45\textwidth}
    \centering
    \includegraphics[scale=0.6]{figs/police_office.eps}
    \caption{Police Office}
    \label{fig:police_office}
  \end{subfigure}

  \caption{Special buildings}
  \label{fig:special_buildings}
\end{figure}
%%

\paragraph{Properties}
%%
\begin{itemize}
  \item \texttt{brokenness}: how structurally damaged the building is; does not change during the simulation
  \item \texttt{fieryness}: the intensity of the fire and fire-related damage in the building
  \begin{itemize}
    \item \texttt{UNBURNT} (not burnt at all)
    \item \texttt{WATER\_DAMAGE} (not burnt at all, but has water damage)
    \item \texttt{HEATING} (on fire a bit)
    \item \texttt{BURNING} (on fire a bit more)
    \item \texttt{INFERNO} (on fire a lot)
    \item \texttt{MINOR\_DAMAGE} (extinguished but minor damage)
    \item \texttt{MODERATE\_DAMAGE} (extinguished but moderate damage)
    \item \texttt{SEVERE\_DAMAGE} (extinguished but major damage)
    \item \texttt{BURNT\_OUT} (completely burnt out)
  \end{itemize}
  \item \texttt{floors}: the number of floors the building has
  \item \texttt{ground area}: the area of each floor
  \item \texttt{ignition}: indicates if the simulator has lit this building on fire\footnote{A building can catch on fire by being ignited by the simulator or by being close to a burning building; ignition will be set to "1" if the building was, at some point of the simulation, ignited by the simulator}
  \item \texttt{importance}: (unknown function; has equal values to all buildings)
  \item \texttt{temperature}: temperature of the building; if it crosses a certain threshold, the building catches on fire
  \item \texttt{total area}: the total area of the building (\texttt{floors X ground area})
\end{itemize}
%%

Regular buildings are represented as polygons of various colors, depending of their status, as shown in Figure~\ref{fig:building_status}; the darker the color, the greater the structural fire or water damage.
%%
\begin{figure}[ht]
  \centering
  \includegraphics[width=1.0\textwidth]{figs/building_status.eps}
  \caption{Possible status of regular buildings}
  \label{fig:building_status}
\end{figure}
%%

In the beginning of the simulation, broken buildings trap humans inside it under debris; these debris must be removed by Ambulance Teams, who then proceeds to rescue the human.

A \emph{refuge} is a special kind of building: it represents a place destined to support the rescue activity, providing medical care for the wounded and water to the Fire Brigades. In the simulator, humans inside a refuge have their damage zeroed, which means they do not lose health while they stay there; damage will, however, resume when the human entity leaves the refuge.

Also, Fire Brigades have their water supply replenished by a certain amount during each cycle while they are inside the refuge.
%%
\subsubsection{Roads}
%%
Area entities representing roads have no new attributes besides those of \emph{area} entities.
%%
\subsubsection{Humans}
%%
These are the entities representing humans. In the simulator, they can be \emph{Civilians}, \emph{Ambulance Teams}, \emph{Fire Brigades} or \emph{Police Forces}. They are all represented by circles of different colors, and cannot move by themselves if they are dead or buried.
%%
\begin{itemize}
  \item \texttt{buriedness}: how deep the human is buried
  \item \texttt{damage}: how much HP the human loses per cycle; zeroes when a refuge is reached
  \item \texttt{direction}: direction to where the human is moving (inferred); the Y-axis positive half is zero, and the value increases until   129599 (360*60*60 - 1) seconds anti-clockwise
  \item \texttt{HP}: health points of the human; if it reaches 0, the human dies
  \item \texttt{position}: ID of the entity where the human is; may be an area entity or a human entity (if it is inside an ambulance)
  \item \texttt{position history}: a list of the entities the human has passed during the last cycle, in chronological order
  \item \texttt{stamina}: not implemented; would decrease each time the agent took an action and would be partially replenished at the beginning of each cycle
  \item \texttt{travel distance}: (unknown)
  \item \texttt{X} \& \texttt{Y}: coordinates representing the human in the map
\end{itemize}
%%

The color of each human in the simulator is defined by its type and its health: the lower its health, the darker it is. Dead humans are represented by the black color.
%%
\subsubsection{Civilians}

Civilians are human entities and they are not part of a rescue team; they are represented by the color green. Their standard behavior is to walk to the closest refuge on their on if they are not wounded or buried; otherwise, they will have to be transported by an Ambulance Team.
%%
\subsection{Agents}

These are the entities that will compose your rescue team; in other words, this is what you will program. Agents are divided in two types: \emph{platoon agents} and \emph{central agents}.

\subsubsection{Platoon agents}

\emph{Platoon agents} are able to interact with the simulated environment through perception and executing actions on it. They can also exchange messages with other agents by vocal or radio communication. They are comprised of three different categories: the \emph{Ambulance Team}, \emph{Fire Brigade} and \emph{Police Force}.

\paragraph{Ambulance Team}

\emph{Ambulance Teams} are responsible for rescuing humans (agents and civilians) and take them to a refuge. They are able to unbury victims and carry one person.

\paragraph{Fire Brigade}

\emph{Fire brigades} are responsible for extinguish fires on buildings. Moreover, they carry a certain amount of water in their tanks and they can replenish it in a refuge.

\paragraph{Police Force}

\emph{Police forces} are responsible for removing blockades from the roads. When ordered to do so, they will clean a certain amount, specified in the repair cost parameter, from the target blockade at each cycle. However, differently from Ambulance Teams and Fire Brigades, having two Police Forces acting on the same blockade brings no advantage to the process: it will be as though there was only one Police Force acting on it.
%%
\subsubsection{Central agents}
%%
\emph{Central agents} are a type of agents whose only interaction with the world is through radio communication. There are three types of central agents: \emph{Ambulance Centers}, \emph{Fire Stations} and \emph{Police Offices}, and they are represented as buildings.
%%
\subsection{Perception and Commands}
%%
The simulator has two perception modes: \emph{standard} and \emph{line of sight}. We will discuss just the latter, since it is the one used in competitions.

Line of sight perception simulates visual perception of the agent: a vision range and a number of rays are defined and the agent percepts anything that is reached by these rays.
%%
\begin{figure}[htp]
  \centering
  \begin{subfigure}[hb]{0.45\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figs/no_los.eps}
    \caption{No LoS}
    \label{fig:los_a}
  \end{subfigure}
  \begin{subfigure}[hb]{0.45\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figs/with_los.eps}
    \caption{LoS}
    \label{fig:los_b}
  \end{subfigure}
  \caption{Normal viewer and LoS perception}
  \label{fig:los}
\end{figure}
%%

The set of currently visible entities for an agent is stored in a structure named \emph{ChangeSet}; entities present in it are automatically updated in its world model; that is, if an agent perceives a blockade it did not know that was there before, this blockade is automatically added to its world model. The opposite, though does not happen: if the agent does not perceive a blockade any more, nothing in its world model changes, even if it knew that there was a blockade there before. In that case, the agent will still think that there is a blockade in that road, even though such blockade has already been cleared. Thus, it is up to the agent to figure this out and modify its world model accordingly.
%%
\subsection{Communication}
%%
There are two forms of communication available in the simulator: \emph{direct communication} and \emph{radio communication}. Direct communication, done with the command \emph{speak}, is communication audible to humans within a radius from the emitter agent, as if the emitter shouted something.

Radio communication is done with the command \emph{tell}, and transmits information to all agents that are signed up to the channel on which it was broadcasted. Radio communication channels are present in limited number, each one with a limited bandwidth.

In both types of communication, the message has to be coded into a string of bytes before being sent; the receptor must decode it once it receives the message. Both types might be susceptible to message \emph{drop out}, where the message is not received by its targets; radio communication is also susceptible to message \emph{failure}, where the message is received empty.
%%
\bibliographystyle{apalike}
\bibliography{references}
%%
\end{document}
%%